1.What docker compose actually does
    Images vs containers: An image is the package. A container is a running instance of an image.
    docker-compose.yml references two images:
        ghcr.io/coleifer/sqlite-web:latest
        ngrok/ngrok:latest

    run docker compose up -d, Docker will:
        pull those images if they’re not present locally, then
        start containers from them (sqliteweb and ngrok-sqliteweb).
        So compose brings up both containers; it doesn’t “build” them unless you define a build: section.

1.Options for distribution
    Option A — Publish a tiny compose repo (recommended)
        don’t build any image yourself.
        Put docker-compose.yml and ngrok/ngrok.yml in a GitHub repo.
        Anyone can clone, set their ngrok token in ngrok.yml, and run:
            docker compose up -d
            This is the most portable way across Linux, macOS, Windows. Differences (paths, ports)
            are handled via a .env file. Example .env (alongside compose):

                HOST_PORT=9090
                DB_FOLDER=/var/lib/smart-monitor
                DB_FILE=smart_factory_monitor.db
                version "3.8"

                services:
                    sqliteweb:
                        image: ghcr.io/coleifer/sqlite-web:latest
                        container_name: sqliteweb
                        restart: unless-stopped
                        ports:
                            - "${HOST_PORT}:8080" #guest vm port:container_port
                        environment:
                            SQLITE_DATABASE: "${DB_FILE}"
                        volumes:
                            - /var/lib/smart-monitor:/data:Z,ro       # mount DB folder as read-only
                            - ${DB_FOLDER}:/var/log/sqliteweb       # persist logs here
                        command:  sh -c "mkdir -p /var/log/sqliteweb && sqlite_web /data/${SQLITE_DATABASE} > /var/log/sqliteweb/access.log 2>&1"

                    ngrok:
                        image: ngrok/ngrok:latest
                        container_name: ngrok-sqliteweb
                        restart: unless-stopped
                        depends_on:
                            - sqliteweb
                        command: ["start", "--all", "--config", "/etc/ngrok/ngrok.yml"]
                        volumes:
                            - ./ngrok/ngrok.yml:/etc/ngrok/ngrok.yml:ro
                volumes:
                    sqliteweb_logs:  # named volume for sqliteweb logs


            On Windows, users just change DB_FOLDER=C:\path\to\dbdir in .env.
            zero maintenance images, upstream security fixes flow in.
            needs internet to pull the two public images.

    Option B — Build own single image (sqlite-web + ngrok together)
        Building one image on Docker Hub that users can just docker run anywhere (Linux, Mac, Windows with Docker Desktop).

        Layout:
            Dockerfile
            entrypoint.sh

        Dockerfile (multi-arch friendly)

            FROM python:3.12-alpine

            # Install sqlite-web
            RUN pip install --no-cache-dir sqlite-web==0.6.7

            # Fetch ngrok
            ARG NGROK_ARCH=linux-amd64
            RUN wget -qO /tmp/ngrok.zip https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-${NGROK_ARCH}.zip \
                && unzip /tmp/ngrok.zip -d /usr/local/bin \
                && rm /tmp/ngrok.zip

            # Create app user and dirs
            RUN adduser -D app && mkdir -p /data /etc/ngrok /var/log/smartmon \
                 && chown -R app:app /data /etc/ngrok /var/log/smartmon \

            USER app

            # Defaults (override at runtime)
            ENV SQLITE_DATABASE=smart_factory_monitor.db
            ENV NGROK_AUTHTOKEN=""
            ENV NGROK_ADDR=127.0.0.1:8080
            ENV NGROK_BASIC_AUTH=""
            ENV PORT=8080

            COPY entrypoint.sh /entrypoint.sh
            EXPOSE 8080
            ENTRYPOINT ["/entrypoint.sh"]


        Entrypoint.sh

            #!/usr/bin/env bash
            set -Eeuo pipefail

            # --- defaults ---
            : "${PORT:=8080}"
            : "${SQLITE_DATABASE:=smart_factory_monitor.db}"
            : "${NGROK_ADDR:=127.0.0.1:8080}"          # can be host:port or full http(s):// URL
            : "${NGROK_AUTHTOKEN:=}"                   # pass at docker run time
            : "${NGROK_BASIC_AUTH:=}"                  # comma-separated "user:pass,user2:pass2"

            mkdir -p /var/log/smartmon
            DB="/data/${SQLITE_DATABASE}"

            # Validate DB is readable
            if [[ ! -r "$DB" ]]; then
              echo "[ERROR] DB not readable at: $DB" >&2
              ls -l /data || true
              exit 1
            fi

            # Normalize upstream to a full URL for ngrok v3
            if [[ "$NGROK_ADDR" =~ ^https?:// ]]; then
              UPSTREAM="$NGROK_ADDR"
            else
              UPSTREAM="http://$NGROK_ADDR"
            fi

            # Start sqlite-web (read-only UI)
            sqlite_web --read-only --host 0.0.0.0 --port "$PORT" "$DB" \
              > /var/log/smartmon/sqliteweb.log 2>&1 &
            SQLITE_PID=$!

            # Build ngrok v3 config if we have a token (the agent also accepts NGROK_AUTHTOKEN from env)
            NGROK_LOG="/var/log/smartmon/ngrok.log"
            : > "$NGROK_LOG"

            if [[ -n "$NGROK_AUTHTOKEN" ]]; then
              {
                echo 'version: "3"'
                echo 'endpoints:'
                echo '  - name: sqliteweb'
                echo '    upstream:'
                echo "      url: \"$UPSTREAM\""
                # optional Basic Auth via traffic policy
                if [[ -n "$NGROK_BASIC_AUTH" ]]; then
                  echo '    traffic_policy:'
                  echo '      on_http_request:'
                  echo '        - actions:'
                  echo '            - type: basic-auth'
                  echo '              config:'
                  echo '                credentials:'
                  IFS=',' read -ra CREDS <<< "$NGROK_BASIC_AUTH"
                  for c in "${CREDS[@]}"; do
                    echo "                  - \"${c}\""
                  done
                fi
              } > /etc/ngrok/ngrok.yml

              # Start v3 agent: reads NGROK_AUTHTOKEN from env; config defines the endpoint
              ngrok start --all --config /etc/ngrok/ngrok.yml > "$NGROK_LOG" 2>&1 &
              NGROK_PID=$!
            else
              NGROK_PID=""
            fi

            # Graceful shutdown
            trap '[[ -n "${NGROK_PID}" ]] && kill "$NGROK_PID" 2>/dev/null || true; kill "$SQLITE_PID" 2>/dev/null || true' INT TERM

            # Stream logs
            tail -F /var/log/smartmon/sqliteweb.log "$NGROK_LOG" &
            TAIL_PID=$!

            # Wait on children
            wait -n "$SQLITE_PID" ${NGROK_PID:+$NGROK_PID} "$TAIL_PID"


        Make it executable:
            chmod +x entrypoint.sh


        Build & push multi-arch-> docker-build-image.sh (so it runs on Intel/AMD and ARM):
        #!/usr/bin/env bash

        set -Eeuo pipefail

        # Optional: load a local .env if present (so DOCKER_HUB_NAME/DOCKER_HUB_TOKEN work)
        # absolute path to this script's directory (works even if called via symlink)
        SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
        ENV_FILE="${ENV_FILE:-$(realpath "$SCRIPT_DIR/../../.env")}"

        echo "$SCRIPT_DIR"
        echo "$ENV_FILE"

        if [[ -f "$ENV_FILE" ]]; then
          set -a
          # shellcheck disable=SC1090
          source <(sed -e 's/\r$//' "$ENV_FILE")
          set +a
        else
          echo "Missing .env at: $ENV_FILE" >&2
          exit 1
        fi

        # Require these to be set (either exported or in .env)
        : "${DOCKER_HUB_NAME:?Set DOCKER_HUB_NAME (Docker Hub username)}"
        : "${DOCKER_HUB_TOKEN:?Set DOCKER_HUB_TOKEN (Docker Hub access token)}"

        # Ensure a buildx builder exists
        docker buildx inspect >/dev/null 2>&1 || docker buildx create --use

        # Non-interactive login (works in scripts/CI)
        echo "$DOCKER_HUB_TOKEN" | docker login -u "$DOCKER_HUB_NAME" --password-stdin

        # Build & push multi-arch
        docker buildx build --platform linux/amd64,linux/arm64 \
          -t "$DOCKER_HUB_NAME/smartmon-sqliteweb:latest" \
          --push .


        How users run it (any OS):
            # read-only DB mount for safe sharing
            docker run -d \
              -p 9090:8080 \
              -p 4040:4040  \
              -v /var/lib/smart-monitor:/data:Z,ro \  # :Z for Debian/Ubuntu but not :Z for MacOs/CentOs
              -e SQLITE_DATABASE=smart_factory_monitor.db \
              -e NGROK_AUTHTOKEN=xxxxxx \
              -e NGROK_ADDR=localhost:8080 \
              -e NGROK_BASIC_AUTH=demo:demo123 \
              --user 0:0 \
              yourhub/smartmon-sqliteweb:latest

        Local access: http://localhost:9090/
        Public URL: check docker logs for ngrok forwarding link.


2.Environment differences & portability
    Paths are the only real difference:
        Linux: /var/lib/smart-monitor:/data:ro
        Windows: C:\path\to\dbdir:/data:ro
        SELinux :Z is only for Fedora/CentOS hosts; omit on Windows/macOS.
        Ports are portable: -p HOSTPORT:8080 works the same on all platforms.
        CPU architectures: publish multi-arch images (buildx) so it runs on Intel/AMD and Apple Silicon.