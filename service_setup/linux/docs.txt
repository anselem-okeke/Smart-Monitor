Why run the orchestrator as a service (Production)
    -Auto-start on boot: no one has to SSH in and start it.
    -Supervision & auto-restart: if your process crashes, the service manager restarts it.
    -Centralized logs: view with journalctl (Linux) or Event Viewer (Windows).
    -Security: run under a restricted user, limit filesystem access.
    -Config separation: keep runtime options (DB path, DRY_RUN) outside code.
    -Single command ops: start/stop/status become predictable.

Linux (systemd) — step-by-step (with “why”)
    -Assuming your repo(code) lives at /opt/smart-monitor and your entrypoint is /opt/smart-monitor/main.py.

1) Create a dedicated user (why: least privilege)
    sudo useradd --system --home /nonexistent --shell /usr/sbin/nologin smartmonitor || true
    or
    sudo useradd -r -s /usr/sbin/nologin smartmonitor || true
    sudo install -d -m 0770 -o smartmonitor -g smartmonitor /var/lib/smart-monitor
    sudo usermod -aG smartmonitor vagrant   # let your shell user access the DB

    If issues arises, give smartmonitor user broad sudo rights (not least-privilege, but fast).

        -Open sudoers safely
            sudo visudo

        -Add this line at the end
            smartmonitor ALL=(ALL) NOPASSWD:ALL

        -Save & exit
            Visudo will validate the syntax.

2) (Optional) Create a Python venv (why: stable deps)
    cd /opt/smart-monitor
    python3 -m venv .venv
    sudo /opt/smart-monitor/.venv/bin/pip install --upgrade pip
    sudo /opt/smart-monitor/.venv/bin/pip install -r requirements.txt

If you don’t use a venv, point ExecStart to /usr/bin/python3 later.

3) Prepare runtime directories (why: write permissions only where needed)
    sudo mkdir -p /var/lib/smart-monitor         # DB/state lives here
    sudo chown smartmonitor:smartmonitor /var/lib/smart-monitor

4) Create an environment file (why: config without code edits)
    sudo mkdir -p /etc/smart-monitor
    sudo tee /etc/smart-monitor/env >/dev/null <<'EOF'
    DRY_RUN=true
    SMARTMONITOR_DB_PATH=/var/lib/smart-monitor/smart_factory_monitor.db
    PYTHONUNBUFFERED=1
    LOG_LEVEL=INFO
    EOF

5) Create the systemd unit (why: supervision + lifecycle)
    /etc/systemd/system/smart-monitor.service

    [Unit]
    Description=Smart-Monitor Orchestrator
    After=network-online.target
    Wants=network-online.target

    [Service]
    Type=simple
    # Use your venv Python (or /usr/bin/python3 if no venv)
    ExecStart=/opt/smart-monitor/.venv/bin/python /opt/smart-monitor/main.py
    WorkingDirectory=/opt/smart-monitor
    EnvironmentFile=-/etc/smart-monitor/env
    User=smartmonitor
    Group=smartmonitor
    Restart=always
    RestartSec=5

    # (add hardening later after we confirm it runs)

    [Install]
    WantedBy=multi-user.target

6) Start + enable (why: activate now and on boot)
    sudo systemctl daemon-reload
    sudo systemctl enable --now smart-monitor

7) Verify & tail logs (why: confirm continuous operation)
    systemctl status smart-monitor --no-pager
    journalctl -u smart-monitor -f

    You should see orchestrator’s logs (with scheduling ticks and handler outputs).

8) Harden once it’s stable (why: defense-in-depth)
    Append to the [Service] section:

    NoNewPrivileges=true
    PrivateTmp=true
    ProtectSystem=full
    ProtectHome=true
    ReadWritePaths=/var/lib/smart-monitor
    MemoryDenyWriteExecute=true
    RestrictRealtime=true
    RestrictSUIDSGID=true


    Then:
    sudo systemctl daemon-reload
    sudo systemctl restart smart-monitor


9) Troubleshooting quick hits
    Permission denied on DB → sudo chown -R smartmonitor:smartmonitor /var/lib/smart-monitor
    Module not found → ensure installed in the venv used by ExecStart
    No logs → PYTHONUNBUFFERED=1 in env (already set), make sure your logger prints to stdout/stderr
    Path issues → confirm WorkingDirectory and that main.py imports work from project root



Enable dev environment to use env vars (Optional if no db default path)
     1) Make it permanent for the shell (optional), Append to your ~/.bashrc
         sudo mkdir -p /var/lib/smart-monitor
         echo 'export SMARTMONITOR_DB_PATH=/var/lib/smart-monitor/smart_factory_monitor.db' >> ~/.bashrc
         echo 'export LOG_LEVEL=INFO' >> ~/.bashrc
         source ~/.bashrc

     2) Fix the login profile
        Make sure the login shell exports everything from /etc/smart-monitor/env

        #!/bin/bash
        sudo tee /usr/local/bin/run-smartmon >/dev/null <<'SH'
        #!/usr/bin/env bash
        set -e
        # Export service env for any shell (login or not)
        set -a
        [ -r /etc/smart-monitor/env ] && . /etc/smart-monitor/env
        set +a
        exec python3 /vagrant/Smart-Monitor/main.py "$@"
        SH
        sudo chmod 755 /usr/local/bin/run-smartmon


     3) Now dev run is simply
        sudo systemctl stop smart-monitor
        sudo -u smartmonitor run-smartmon
