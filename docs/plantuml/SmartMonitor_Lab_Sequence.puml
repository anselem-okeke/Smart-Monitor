@startuml SmartMonitor
title Smart-Monitor — Self-Healing Platform FlowChart

' ---------- Participants (compose service names in <<stereotype>>) ----------
participant "Orchestrator/Agent\n<<sm-orchestrator>>" as AG
participant "systemd (D-Bus)\n/mnt /run/dbus" as SYS
participant "Host Helper (opt)\nroot-priv API" as HH
database "PostgreSQL\n<<sm-postgres>>" as DB
participant "Flask API (Gunicorn)\n<<sm-gui>>" as API
participant "Classifier Engine\n(heuristics/baselines)" as CLF
participant "Policy & Safety Layer\n(allow-list, cooldowns, windows)" as POL
participant "Remediator\n(actions, backoff, verify)" as ACT
participant "Logs\n<<log-file>>" as LG
participant "Nginx (TLS/SSE)\n<<sm-nginx>>" as NGINX
participant "Cloudflared (opt)\n<<sm-cloudflared>>" as CF
actor       "Engineer Browser\n(SSE dashboard)" as UI


' ---------- Legend ----------
hnote over AG,UI
Smart-Monitor LAB stack (docker-compose):
- sm-orchestrator-lab (privileged)
- sm-gui (Flask/Gunicorn API)
- sm-postgres (state + audit)
- sm-nginx (TLS + SSE)
- sm-cloudflared (optional- secure port)
end note

' ---------- 1) Sense: collect host/service state ----------
AG -> SYS : Query service states via D-Bus\n(is-active, show SubState/Type/UnitFileState)\n+ read /proc,/sys (CPU, mem, disk IO)
note right of AG
Normalize raw states → {running|stopped|failed|unknown}\nBuild metrics & events batch
end note

' Orchestrator writes metrics/events directly to Postgres
AG -> DB : INSERT metrics & events batch\n(using DB driver)
DB --> AG : ack

' ---------- 2) Think: classify new events and classifications ----------

DB -> CLF : notifyNewBatch(events)
activate CLF
CLF -> DB : Read recent window (Δt) for correlation
CLF <-- DB : timeseries + service history
CLF -> CLF : Heuristics + baselines + state machine\n• failed + retry_exceeded → INCIDENT\n• CPU z-score>k + OOM + service down → MEMORY_PRESSURE\n• flapping(rate) > threshold → FLAPPING
CLF -> DB : INSERT classifications(labels, confidence)
deactivate CLF

' ---------- 3) Decide: policy & safety ----------
API -> POL : evaluate(decisionRequest)\n(labels, service, host, cooldown, window)
activate POL
POL -> DB : read policy (approved_services.json snapshot) & cooldowns\n+ last actions for this svc
POL <-- DB : policy rows
alt Allowed by policy
  POL --> API : APPROVED(actionSpec, guardrails)\n(max_retries, backoff, timeout)
else Denied / Dry-Run
  POL --> LG : DENIED(reason) / DRY_RUN\n(log only)
end
deactivate POL

' ---------- 4) Act: remediation path ----------
alt APPROVED
  API -> ACT : execute(actionSpec)
  activate ACT
  opt Lab (privileged agent executes locally)
    ACT -> AG : requestRemediation(service:restart)
    AG -> SYS : systemctl restart <svc>
    SYS --> AG : result(exit code, SubState)
  end
  opt Production Hardened host (optional helper)
    note over SYS, POL
      Privileged actions only via API key\non hardened host
    end note

    ACT -> HH : POST /actions/restart?svc=<svc>\n(Authorization: API key)
    HH -> SYS : systemctl restart <svc>
    SYS --> HH : result
    HH --> ACT : result
    ACT --> LG : Log results to log file
  end
  ACT -> SYS : verify health (is-active) after backoff
  SYS --> ACT : ActiveState=active?
  ACT -> DB : INSERT actions(audit), outcomes, duration
  deactivate ACT
end

' ---------- 5) Live updates to UI via SSE ----------
par Live stream (SSE)
  API -> NGINX : push events → /api/stream/alerts (SSE)
  NGINX -> UI : event: classification/action\n{id, svc, label, decision, outcome}
end

' ---------- 6) Optional public egress via Cloudflared ----------
opt Public egress (optional)
  UI -> CF : https://<tunnel-host>/ …
  CF -> NGINX : proxied HTTPS (QUIC)
  NGINX -> API : upstream to Flask
end

' ---------- 7) Failure handling / circuit breaker ----------
group If remediation fails repeatedly
  ACT -> ACT : exponential backoff + jitter
  ACT -> POL : circuitBreaker.trip?(svc)
  POL --> ACT : trip if attempts > limit in window
  ACT -> DB : log escalation + stop automated actions
  API -> UI : SSE event: escalation_required
end

' ---------- 8) Manual follow-up ----------
UI -> API : POST /api/acknowledge or /api/runbook-link
API -> DB : record user ack / note / runbook ref

' ---------- End ----------
hnote over UI
Dashboard panes:
• Current service health & labels
• Recent incidents and actions
• SSE live ticker
• Audit trail & MTTR trends
end note

@enduml
